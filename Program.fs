open System

[<EntryPoint>]
let main argv =
    printfn "Welcome to the program, program!"

    
    // stuff goes here
    let planetRadius = 6378137.0  // Radius of Earth in meters
    let EarthMass = 5973600000000000000000000.0
    let mutable ExcessEscapeVelocity = None // My Independent Variable (in m/s)

    let mutable t = 0.0                 // time from launch in seconds
    let TimeStep = 0.01                 // Timefactor (seconds per cycle) lower = more accurate but slower
    let CounterLimit = 10               // How many iterations the counter will go up to before triggering and reseting
    let Counter = 0                     // counts iterations up until a given number then resets
    let simRunTime = 7200               // run time

    let mutable MachNo = 0.0
    let mutable StageNo = 1
    let mutable localPressure = 0.0     // pressure of local atmosphere in Pascals
    let mutable T = 15.0                // temperature of local atmosphere in degrees C
    let mutable h = 0.0                 // height in meters from sea level
    let C = 120.0                       // Sutherland's constant for air
    let To = 18.0                       // Reference temperature for viscosity equation
    let mutable u = 0.0                 // Viscosity of the air in centipoise
    let yg = 1.40                       // ratio of specific heat of at constant pressure to that at constant volume (is constant)
    let mutable c = 340.0               // local speed of sound in m/s
    let mutable MachNo = 0.0
    let M:float = v.getLaunchMass(StageNo)
    let mutable ThrustN = 0.0           // Thrust generated by currently used thrusters in newtons
    let mutable V = 0.0                 // current velocity m/s
    let EscV = 11186.0                  // Escape Velocity of Earth in m/s
    let mutable forceOfDrag = 0.0       // Drag force in Newton
    let mutable x = planetRadius        // x coordinate in meters (0,0 is center of earth)
    let mutable y = 0.0                 // y coordinate in meters
    let mutable VelocityX = 0.0         // Velocity along the x axis
    let mutable VelocityY = 0.0         // Velocity along the y axis
    let mutable PolarCoordMag = planetRadius // distance from center (polar coordinates)
    let mutable velocityAngle = 0.0
    let mutable PolarCoordDeg = 0.0     // angle from 0 in degrees (polar coordinates)
    let mutable xT = 0.0                // Thrust in x direction
    let mutable yT = 0.0                // Thrust in y direction
    let mutable thrustWeightRatio = 0.0
    let mutable F = 0.0                 // net force (after drag)
    let mutable xF = 0.0                // force along the x axis
    let mutable yF = 0.0                // force along the y axis
    let GravConst = 0.0000000000667359  //Gravitational constant

    let gs = 9.80665                    // gravity at surface level in m/s^2
    let mutable GravAng = 180.0           // direction of gravity's pull from the reference point of the spacecraft
    let mutable g = 9.80665             // current percieved acceleration due to gravity in m/s
    let mutable GravForceX = 0.0                // force of gravity in the x direction in Newtons
    let mutable GravForceY = 0.0                // force of gravity in the y direction in Newtons
    let mutable accel = 0.0             // current acceleration in m/s^2 (after gravity)
    let mutable HeadingDeg = 0.0        // heading in degrees, 0 is up (also opposite of direction of force) (where you are pointing)
    let mutable t_str = '0'             // time in seconds in string form for naming structures
    let mutable localAirDensity = 0.0   // density of local air in kg/m^3
    let MMA = 28.9644                   // molar mass of Earth's air in kg/mol
    let Rugc = 8314.32                  // universal gas constant J/mol/K
    let altRugc = 286.0                 // alternative universal gas constant
    let mutable FlightPathDeg = 0.0     // flight path angle in degrees (where you are going)
    let mutable GravForce = 0.0         // Force of gravity in Newtons
    
    let mutable plsStop = 0

    while (plsStop = 0) do
        t <- t + TimeStep
        //  atmospheric details
        if (h <= 11000.0) then                               // pressure, density, and temperature functions for under 11000 meters
            let temp_lapse_ratek = -0.0065
            T <- 15.0 + (temp_lapse_ratek * h)
            let static_pressure = 101325.0
            let standard_tempk = 288.15
            let layer_heightm = 0.0
            let default_layer_density = 1.2250
            let pa = standard_tempk / ((standard_tempk + (temp_lapse_ratek * (h - layer_heightm))))
            let pb = (gs * MMA) / (Rugc * temp_lapse_ratek)
            localPressure <- static_pressure * (pa ** pb)
            localAirDensity <- (default_layer_density * (pa ** (1.0 + pb)))
        elif (h <= 20000.0) then                            // pressure, density, and temperature functions for under 20000 meters
            T <- -56.5
            let default_layer_density = 0.36391
            let static_pressure = 22632.10
            let layer_heightm = 11000.0
            let standard_tempk = 216.65
            localPressure <- static_pressure * exp ((-gs * MMA * (h-layer_heightm)) / (Rugc * standard_tempk))
            localAirDensity <- default_layer_density * exp ((-gs * MMA * (h-layer_heightm)) / (Rugc * standard_tempk))
        elif (h <= 32000.0) then                            // pressure, density, and temperature functions for under 32000 meters
            let static_pressure = 5474.89
            let standard_tempk = 216.65
            let temp_lapse_ratek = 0.001
            let layer_heightm = 20000.0
            T <- -56.5 + temp_lapse_ratek * (h-layer_heightm)
            let default_layer_density = 0.08803
            let pa = standard_tempk / ((standard_tempk+(temp_lapse_ratek*(h-layer_heightm))))
            let pb = (gs * MMA) / (Rugc * temp_lapse_ratek)
            localPressure <- static_pressure * (pa ** pb)
            localAirDensity <- default_layer_density * (pa ** (1.0+pb))
        elif (h <= 47000.0) then                            // pressure, density, and temperature functions for under 47000 meters
            let static_pressure = 868.02
            let standard_tempk = 228.65
            let layer_heightm = 32000.0
            let temp_lapse_ratek = 0.0028
            T <- -56.5 + 0.0028*(h-layer_heightm)
            let default_layer_density = 0.01322
            let pa = standard_tempk / ((standard_tempk+(temp_lapse_ratek * (h-layer_heightm))))
            let pb = ((gs*MMA) / (Rugc*temp_lapse_ratek))
            localPressure <- static_pressure * (pa ** pb)
            localAirDensity <- default_layer_density * (pa ** (1.0+pb))
        elif (h <= 51000.0) then                            // pressure, density, and temperature functions for under 51000 meters
            T <- -2.5
            let static_pressure = 110.91
            let standard_tempk = 270.65
            let layer_heightm = 47000.0
            let default_layer_density = 0.00143
            localPressure <- static_pressure * exp((-gs*MMA*(h-layer_heightm))/(Rugc*(standard_tempk)))
            localAirDensity <- default_layer_density * exp((-gs*MMA*(h-layer_heightm))/(Rugc*(standard_tempk)))
        elif (h <= 71000.0) then                            // pressure, density, and temperature functions for under 71000 meters
            T <- -2.5 + (-0.0028*(h-51000.0))
            let static_pressure = 66.94
            let temp_lapse_ratek = -0.0028
            let standard_tempk = 270.65
            let layer_heightm = 51000.0
            let default_layer_density = 0.00086
            let pa = standard_tempk / ((standard_tempk + (temp_lapse_ratek * (h - layer_heightm))))
            let pb = ((gs * MMA)/(Rugc * temp_lapse_ratek))
            localPressure <- static_pressure * (pa ** pb)
            localAirDensity <- default_layer_density * (pa ** (1.0+pb))
        elif (h <= 86000.0) then                            // pressure and temperature functions for under 86000 meters
            T <- -58.5 + (-0.002 * (h-71000.0))
            let static_pressure = 3.96
            let temp_lapse_ratek = -0.002
            let standard_tempk = 214.65
            let layer_heightm = 71000.0
            let default_layer_density = 0.000064
            let pa = standard_tempk/((standard_tempk+(temp_lapse_ratek*(h-layer_heightm))))
            let pb = ((gs*MMA)/(Rugc*temp_lapse_ratek))
            localPressure <- static_pressure * (pa ** pb)
            localAirDensity <- default_layer_density * (pa ** (1.0+pb))
        else
            localPressure <- 0.0
            localAirDensity <- 0.0
            

    thrustWeightRatio <- ThrustN / (M * g)

    c <- sqrt(yg * altRugc * (T+273.15))                                  // Local speed of sound (m/s)
    MachNo <- V/c
    u <- 0.01827 * ((To + 273.15 + C) / (T+ 273.15 + C)) * (T / To ** 3.0/2.0) // Viscocity from temperature and sutherland's constant in centipoise
    let forceDragX = forceOfDrag * cos(math.radians(FlightPathDeg))     // Force of drag in newtons along x
    let forceDragY = forceOfDrag * sin(math.radians(FlightPathDeg))     // Force of drag in newtons along y
    xT <- ThrustN * cos(math.radians(HeadingDeg))                       // thrust along the x axis
    yT <- ThrustN * sin(math.radians(HeadingDeg))                       // thrust along the y axis
    g <- gs * (planetRadius/PolarCoordMag ** 2.0)                       // acceleration due to gravity
    GravAng <- PolarCoordDeg                                            // Direction of acceleration due to gravity from spacecraft's reference point in degrees
    GravForce <- g*M                                                    // Force of gravity in Newtons
    GravForceX <- 0.0 - (GravForce * cos(math.radians(GravAng)))        // Force due to gravity (in Newtons) in the x direction from g and the negative of the polar position in degrees
    GravForceY <- 0.0 - (GravForce * sin(math.radians(GravAng)))        // Force due to gravity (in Newtons) in the y direction from g and the negative of the polar position in degrees
    xF <- xT + GravForceX + forceDragX                                  // Total force along x in Newtons
    yF <- yT + GravForceY + forceDragY                                  // Total force along y in Newtons
    let Ax = xF/M                                                       // Acceleration along x in m/s
    let Ay = yF/M                                                       // Acceleration along y in m/s
    accel <- sqrt ((Ax ** 2.0) + (Ay ** 2.0))                           // Acceleration as axes into a vector
    VelocityX <- VelocityX + (Ax*TimeStep)                              // speed in x changes due to acceleration
    VelocityY <- VelocityY + (Ay*TimeStep)                              // speed in y changes due to acceleration
    V <- sqrt(VelocityX ** 2.0) + (VelocityY ** 2.0)
    x <- x + (VelocityX*TimeStep)                                       // position in x changes due to acceleration along x
    y <- y + (VelocityY*TimeStep)
    
    PolarCoordDeg <- math.degrees(math.atan2(y, x))
    if PolarCoordDeg < 0.0 then
        PolarCoordDeg <- PolarCoordDeg + 360.0
    PolarCoordMag <- sqrt((x ** 2.0) + (y ** 2.0))

    h <- PolarCoordMag - planetRadius

    let velocityAngle = math.degrees(math.atan2(VelocityY, VelocityX))
    FlightPathDeg <-
        if velocityAngle < 0.0 then
            velocityAngle + 360.0
        elif velocityAngle > 360.0 then
            velocityAngle - 360.0
        else
            velocityAngle

    let dynamicQ = localPressure * (V ** 2.0) * 0.5
    if (h < 0.0) then
        plsStlop <- 1
        print ("BOOOOM!  Hit the ground at t=%s" % t)
    //HeadingDeg, kickHeight, kickAngleDeg = v.PitchControl(t, TimeStep, h, FlightPathDeg, HeadingDeg, PolarCoordDeg)
    HeadingDeg, kickAngleDeg, kickHeight = v.PitchControl(t, TimeStep, h, FlightPathDeg, HeadingDeg, PolarCoordDeg, dynamicQ)

  // Accumulate records every 100 itterations
    Counter = (Counter + 1)
    if (Counter == CounterLimit):
        Counter = 0;
        all_t.append(t)                  # These lines record the current values in the one_time structre
        all_y.append(y)
        all_h.append(h)
        all_StageNo.append(StageNo)
        all_localPressure.append(localPressure)
        all_accel.append(accel)
        all_localAirDensity.append(localAirDensity)
        all_Ax.append(Ax)
        all_Ay.append(Ay)
        all_HeadingDeg.append(HeadingDeg)
        all_V.append(V)
        all_VelocityX.append(VelocityX)
        all_VelocityY.append(VelocityY)
        all_x.append(x)
        all_GravForce.append(GravForce)
        all_forceOfDrag.append(forceOfDrag)
        all_FlightPathDeg.append(FlightPathDeg)
        all_GravAng.append(GravAng)
        all_ThrustN.append(ThrustN)
        all_PolarCoordMag.append(PolarCoordMag)
        all_PolarCoordDeg.append(math.radians(PolarCoordDeg))
        all_dynamicQ.append(dynamicQ)
    if (t >= simRunTime):
        stop = 1
    print ("Done! Stop value:%s" % stop)

    0